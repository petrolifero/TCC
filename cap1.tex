\chapter{Introdução}

%%%% Sobre o que trata este trabalho?
%%%% Por que este trabalho foi feito? (A importância de continuações como mecanismo de controle. Pi automato como um modelo simples para ensino de compiladores feito no ic/uff no qual continuacoes sao explicitas.) 
%%%% Como foi feito?

Esse trabalho trata da adição de continuações à um Framework semântico para ensino de compiladores chamado $\Pi$ Framework. Continuações apresentam um controle de fluxo não-local. 

Continuações surgiram na linguagem scheme através da função call-with-current-continuation, ou \texttt{call/cc}. Ela apresenta importância prática e teórica, sendo possível utiliza-la para implementar \texttt{amb}, corotinas, continuações delimitadas e exceções, além de, no isomorfismo de Curry-Howard, sua adição (e portanto a adição de seu tipo) permitir expressar teoremas clássicos em um sistema anteriormente intuicionista.

O $\Pi$ Framework é um modelo criado por Christiano Braga para ensino da disciplina de compiladores. Este framework contém elementos básicos para descrever a semântica de reescrita de linguagens de programação, como estruturas de repetição, decisão, procedimentos e funções recursivas.

Esse capitulo dará uma breve exposição dos recursos tratados ou utilizados para a produção desta monografia. O Capítulo \ref{cap2} definirá em maiores detalhes o estado atual da maquina abstrata utilizada para dar semântica a linguagens de programação. O capítulo \ref{cap3} adicionará ao capítulo \ref{cap2} as contribuições do autor a esta maquina. O capitulo 4 exemplificará como as novas primitivas podem ser utilizadas para descrever a semântica de construções como retorno de funções e corotinas. O capítulo 5 citará os trabalhos que influenciaram a presente monografia ou atacaram o mesmo problema de semântica formal. Finalmente, ocorrerá a conclusão da presente monografia.

\section{Racket}
Racket\footnote{https://racket-lang.org/}, inicialmente chamada de plt-scheme, é uma linguagem baseada em lisp criada para ser uma linguagem para desenvolver linguagens. Multi-paradigma, priorizando estruturas de dados imutáveis, com um sistema de meta-programação baseado em macros higiênicas. Com extensa facilidade para realizar pattern matching, Racket foi a linguagem escolhida para desenvolver esse trabalho. O principal procedimento desenvolvido pelo autor, a saber, a função de transição do sistema, faz uso extenso do pattern matching, permitindo que as regras de transição sejam codificadas sem maior esforço, de uma maneira declarativa.

Ex:
    Dada uma estrutura \texttt{add}, contendo dois membros númericos, sua avaliação dada através da regra
    $$(\texttt{add a b)} \xrightarrow{} a+b  $$
    Pode ser codificada como a função \texttt{evalExpression} dada por
    
    \begin{verbatim}
    (define (evalExpression exp)
    
            (match exp
            
            [(add a b) (+ a b)]))
    \end{verbatim}
    
\section{$\Pi$ Autômato}
O $\Pi$ Autômato é uma maquina utilizada dentro do $\Pi$ framework para descrever a semântica de linguagens de programação através do grafo gerado pelas suas transições. Contém em sua estrutura os bindings gerados pela execução de um programa, além dos valores intermediários necessários a computação corrente (caso se esteja computando $1+(1+x)$, em sua estrutura existe o valor correspondente a x e, quando da realização da última soma, o valor armazenado de $1+x$).
\section{Continuações}
Uma continuação é uma representação do futuro de uma computação. Normalmente representada como uma função de um único parâmetro. Na expressão $1+(1+x)$, quando se esta avaliando o valor de $(1+x)$, a continuação se parece com $\lambda(x) 1+x$. Normalmente as continuações são, em uma dada linguagem, implícitas, dadas pela sequência de execuções do programa. As continuações podem ser dadas explicitamente caso o programa esteja escrito em continuation passing style (CPS). 
\section{Call/cc}
\subsection{Call/cc em Racket}
\subsubsection{Ret}
\subsubsection{Call/cc}
\subsubsection{Co-rotinas}